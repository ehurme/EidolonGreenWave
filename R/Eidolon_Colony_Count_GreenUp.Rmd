---
title: "Eidolon Colony Count Green Up"
author: "Edward hurme"
date: "10/26/2020"
output: html_document
editor_options: 
  chunk_output_type: inline
---

Here I am investigating the relationship between relative colony size and instantaneous rate of green up.

Green up date is estimated by the MCD12Q2.006 Land Cover Dynamics Yearly Global Model at 500m resolution ()

# load libraries
```{r setup, echo=FALSE}
# packrat::init()
# basic toolkit
library(ggplot2)
library(ggformula)
library(dplyr) 
library(tidyverse) # piping
library(scales) 
library(viridisLite) # nice colors
library(ggpubr) # nice plotting
library(readxl) # read xls
library(janitor) # clean column names
library(zoo) # interpolation
library(raster)

# time series
library(lubridate)

# math
require(pracma) # area under the curve

# Mapping
library(rnaturalearth)
library(rnaturalearthdata)

# Species occurrence data
library(rgbif)
library(rinat)

# modeling
library(mgcv)
library(lme4)
library(MuMIn)
# library(tidymodels)
library(vip)


source("../src/IRG_functions.R")
```

# reproducible libraries
```{r}
# library(groundhod)
# 
# groundhog.library(ggplot2, "2021-01-01")
# groundhog.library(ggformula, "2021-01-01")
# groundhog.library(dplyr, "2021-01-01")
# groundhog.library(tidyverse, "2021-01-01")
# groundhog.library(scales, "2021-01-01")
# groundhog.library(viridisLite, "2021-01-01")
# groundhog.library(ggpubr, "2021-01-01")
# groundhog.library("janitor", "2021-01-01")
# groundhog.library("readxl", "2021-01-01")

# 
# groundhog.library("lubridate", "2021-01-01")
# groundhog.library(zoo, "2021-01-01")
# groundhog.library(tstools, "2021-01-01")
# groundhog.library(nlme,'2021-01-01')
# groundhog.library(TTR, "2021-01-01")
# groundhog.library(TSA, "2021-01-01")
# groundhog.library(nlts, "2021-01-01") # spec.lomb - periodogram for unevenly sampled data
# groundhog.library(timeSeries, "2021-01-01")
# groundhog.library(astsa, "2021-01-01")
# 
# groundhog.library(rnaturalearth, "2021-01-01")
# groundhog.library(rnaturalearthdata, "2021-01-01")
# 
# groundhog.library(rgbif, "2021-01-01")
# groundhog.library(rinat, "2021-01-01")
# 
# groundhog.library("lme4", "2021-01-01")
# groundhog.library("MuMIn", "2021-01-01")
```

# load colony data
## original data
```{r}
count <- read.csv("../../../../Dropbox/MPI/Eidolon/Data/Monitoring/monitoring_data.csv")
count$date <- dmy(count$Date)
count$time_diff <- NA
count$ratio <- NA

IDs <- unique(count$Location)
i = 1
for(i in 1:length(IDs)){
  idx <- which(count$Location == IDs[i])
  c <- count[idx,]
  
  # time lag between counts
  count$time_diff[idx] <- c(NA, diff(c$date, units = "days"))
  
  # plot count
  # plot(c$date, c$Count, type = "o", main = IDs[i])
  
  # calculate ratio over moving window of +-1 year?
  j = 1
  for(j in 1:nrow(c)){
    idxx <- which(as.numeric(abs(c$date[j] - c$date), units = "days") <= 365)
    
    cc <- c[idxx,]
    # plot(cc$date, cc$Count, type = "o")
    count$ratio[idx[j]] <- c$Count[j]/max(cc$Count, na.rm = TRUE)
  }
  c <- count[idx,]
  layout(c(1,2))
  plot(c$date, c$Count, type = "o", main = IDs[i])
  plot(c$date, c$ratio, type = "o")
}


ggplot(count, aes(x = date, y = Count, col = Location))+
  geom_point()+
  theme_classic2()+
  facet_wrap(~Location, scales = "free")+theme(legend.position = "none")
```
## Add Richter Data
```{r}

r <- readxl::read_excel("../../../../Dropbox/MPI/Eidolon/Greenwave/data/Count/Richter_Heidi/Bat Count Data2001.xls", sheet = 3)
colnames(r) <- make_clean_names(r[2,])

r <- r[-c(1:3),-4]
r$date <- seq.Date(as.Date("2001-10-22"), as.Date("2002-01-08"), by = 1)
r$mean_number_count <- as.numeric(r$mean_number_count)
plot(r$date, r$mean_number_count*536.4519)
5000000/max(r$mean_number_count, na.rm = TRUE)

r$ratio <- r$mean_number_count/max(r$mean_number_count, na.rm = TRUE)
plot(r$ratio)

r$Long <- count$Long[count$Location == "Kasanka"][1]
r$Lat <- count$Lat[count$Location == "Kasanka"][1]
r$Country <- count$Country[count$Location == "Kasanka"][1]
r$Location <- count$Location[count$Location == "Kasanka"][1]
r$Count <- r$mean_number_count *536.4519
r$Observer <- "Heidi Richter & Graeme Cumming"
r$Doubtful <- ""

count <- full_join(count, r)
```

## load Teague's version
```{r load colony data}

load("../../../../Dropbox/MPI/Eidolon/Greenwave/data/Count/count_ratio.RData")
head(batdf)

raw.data <- batdf
unique(paste0(raw.data$Long, ", ", raw.data$Lat))
tmp <- raw.data %>% group_by(Long, Lat) %>% 
  summarise()
tmp$geeID <- 1:nrow(tmp)

names(tmp) <- c("Long", "Lat", "geeID")

colonies <- inner_join(tmp, count)


```
### how is Teague's ratio calculated?
```{r}

cs <- batdf %>% group_by(Location, year(timestamp)) %>% 
  summarise(custom_ratio = Count/max(Count), timestamp, ratio)

plot(cs$custom_ratio, cs$ratio)

```


## summarize colony data
```{r}
colony_sum <- 
  colonies %>% group_by(Country,Location) %>% 
  summarise(geeID = min(geeID), Lat = min(Lat), Long = min(Long),
            start = min(date), end = max(date), 
            duration = as.numeric(round(diff(c(min(date), max(date)))/365,1)), 
            count = n(), interval = median(diff(date)))

colony_sum
# write.csv(colony_sum, file = "../../../../Dropbox/MPI/Eidolon/Data/Count/colony_sum.csv")

```

## thin to monthly counts
```{r}
reg_colonies <- data.frame()
ids <- unique(colonies$Location)
i = 2


for(i in 1:length(ids)){
  c <- colonies[colonies$Location == ids[i],]
  c <- c[order(c$date),]
  
  # pdf(file = paste0("./plots/Count/", c$Location[1], "_count.pdf"))
  layout(c(1:3))
  plot(c$date, c$ratio, #col = c$change,
         type = "o", xlab = "Time", ylab= "ratio", main = c$Location[1])
  

  # regularize by month
  c <- mutate(c, month = round_date(date, unit = "month"))
  
  # average multiple counts in a month
  monthly_count <- c %>% 
    group_by(Location, Long, Lat, geeID, Country, month) %>% 
    summarise(ratio = mean(ratio, na.rm = TRUE),
              count = mean(Count, na.rm = TRUE),
              Observer = Observer[1])
  if(any(duplicated(monthly_count$month))) print(i)
  
  # fill in missing months
  continuous_count <- monthly_count %>% 
    complete(month = seq.Date(from = min(month), to = max(month), by = "month"))
  
  continuous_count$count <- na.approx(object = continuous_count$count, maxgap = 2)
  continuous_count$ratio <- na.approx(object = continuous_count$ratio, maxgap = 2)

  plot(continuous_count$month, continuous_count$count, type = "o", 
       main = "Interpolated",
       xlab = "month", ylab = "count")
  with(continuous_count[is.na(continuous_count$Observer),], 
       points(month, count, col = 2, pch = 16))
  
  plot(continuous_count$month, continuous_count$ratio, type = "o",
       main = "Interpolated",
       xlab = "month", ylab = "ratio")
  with(continuous_count[is.na(continuous_count$Observer),], 
       points(month, ratio, col = 2, pch = 16))
  
  # dev.off()
  
  # exclude locations with too few?
  tmp <- rle(is.na(continuous_count$Observer))
  
  reg_colonies <- rbind(reg_colonies, continuous_count)
}

save(colonies, count, reg_colonies, file = "../../../../Dropbox/MPI/Eidolon/Greenwave/rdata/colony_count.RData")
```

# load GEE data
```{r load GEE data}
# setwd("./R")

EVI <- read.csv("../../../../Dropbox/GreenWave/EidolonColonies/rawdata/rl_MOD13Q1_EVI_2000_2020_ptsB_EidolonColonies_QCOP1_buf50km.csv")
MEVI1 <- read.csv("../../../../Dropbox/GreenWave/EidolonColonies/rawdata/MODIS_Phen_buf50km_Peak_1_2000_2020_ptsB.csv")
MEVI2 <- read.csv("../../../../Dropbox/GreenWave/EidolonColonies/rawdata/MODIS_Phen_buf50km_Peak_2_2000_2020_ptsB.csv")
MIRG1 <- read.csv("../../../../Dropbox/GreenWave/EidolonColonies/rawdata/MODIS_Phen_buf50km_MidGreenup_1_2000_2020_ptsB.csv")
MIRG2 <- read.csv("../../../../Dropbox/GreenWave/EidolonColonies/rawdata/MODIS_Phen_buf50km_MidGreenup_2_2000_2020_ptsB.csv")
numcycles <- read.csv("../../../../Dropbox/GreenWave/EidolonColonies/rawdata/MODIS_Phen_buf50km_NumCycles_2000_2020_ptsB.csv")
QA1 <- read.csv("../../../../Dropbox/GreenWave/EidolonColonies/rawdata/MODIS_Phen_buf50km_QA_Overall_1_2000_2020_ptsB.csv")
QA2 <- read.csv("../../../../Dropbox/GreenWave/EidolonColonies/rawdata/MODIS_Phen_buf50km_QA_Overall_2_2000_2020_ptsB.csv")
MEVIamp1 <- read.csv("../../../../Dropbox/GreenWave/EidolonColonies/rawdata/MODIS_Phen_buf50km_EVI_Amplitude_1_2000_2020_ptsB.csv")
MEVIamp2 <- read.csv("../../../../Dropbox/GreenWave/EidolonColonies/rawdata/MODIS_Phen_buf50km_EVI_Amplitude_2_2000_2020_ptsB.csv")
MEVIarea1 <- read.csv("../../../../Dropbox/GreenWave/EidolonColonies/rawdata/MODIS_Phen_buf50km_EVI_Area_1_2000_2020_ptsB.csv")
MEVIarea2 <- read.csv("../../../../Dropbox/GreenWave/EidolonColonies/rawdata/MODIS_Phen_buf50km_EVI_Area_2_2000_2020_ptsB.csv")

precip <- read.csv("../../../../Dropbox/MPI/Eidolon/Greenwave/data/GEE/ee_precip_chirps_colonies_2000_2020.csv")
names(precip) <- c("time", 1:17)
precip$time <- dmy(precip$time)
```

## join data
```{r join data}
MEVI1$amp <- MEVIamp1$mean
MEVI2$amp <- MEVIamp2$mean
MEVI1$area <- MEVIarea1$mean
MEVI2$area <- MEVIarea2$mean
MEVI1$IRG <- MIRG1$mean
MEVI2$IRG <- MIRG2$mean
MEVI1$peak <- 1
MEVI2$peak <- 2
MEVI1$QA <- QA1$mean
MEVI2$QA <- QA2$mean

MEVI <- rbind(MEVI1, MEVI2)

MEVI$date_EVI <- ymd("1970-01-01")+MEVI$mean
MEVI$yday_EVI <- yday(MEVI$date_EVI)
MEVI$date_IRG <- ymd("1970-01-01")+MEVI$IRG
MEVI$yday_IRG <- yday(MEVI$date_IRG)

MEVI <- MEVI[order(MEVI$date_EVI),]
# MEVI$lat <- unique(colonies$Lat)

for(i in 1:nrow(MEVI)){
  MEVI$lat[i] <- unique(colonies$Lat[MEVI$geeID[i] == colonies$geeID])
  MEVI$Location[i] <- unique(colonies$Location[MEVI$geeID[i] == colonies$geeID])
}

EVI$time <- ymd_hms(EVI$startDate)
```

# add EVI, IRG, and precipitation to all counts
```{r colony cycles}
IDs <- unique(reg_colonies$geeID)
i = 14
layout(1)
for(i in 1:length(IDs)){
  c <- reg_colonies[reg_colonies$geeID == IDs[i],]
  e <- EVI[EVI$geeID == IDs[i],]
  p <- precip[,c(1,(i+1))]
  names(p) <- c("time", "mean")
  # layout(rbind(1,2))

  with(c, plot(month, ratio, type = "o", 
               pch = 16, col = as.numeric(is.na(Observer))+1,
               ylim = c(0,1),
               main = paste0(Location[1],", ", Country[1] , "; ID = ", geeID[1])))
  with(e, points(as.Date(time), mean/max(mean), type = "o", col = 3, pch = 16))
  with(p, points(as.Date(time), mean/max(mean), type = "o", col = 4, pch = 16))
  with(c, points(month, ratio, type = "o", 
               pch = 16, col = as.numeric(is.na(Observer))+1))
}

```
# add IRG to EVI
```{r}
IDs
EVI$IRG <- NA
EVI$Lat <- NA
for(i in 1:length(IDs)){
  idx <- which(EVI$geeID == i)
  e <- EVI[idx,]
  time <- e$time
  evi <- e$mean
  
  spl <- smooth.spline(x = time, y = evi)
  pred <- predict(spl)
  e$pred <- pred$y
  # get derivative of EVI -> IRG
  pred.prime <- predict(spl, deriv=1)
  plot(pred.prime, type = "l")
  # pred.prime$y_scale <- rescale(pred.prime$y, c(0,1))
  # plot(pred.prime$x, pred.prime$y_scale, type = "l")
  EVI$IRG[idx] <- pred.prime$y
  
  EVI$Lat[idx] <- colonies$Lat[which(colonies$geeID == i)[1]]
}
```


# ggplot
```{r}
ggplot(EVI, aes(x = month(time)))+
  geom_smooth(col = 3, aes(y = mean/max(mean), se = FALSE, group = geeID))+
  geom_smooth(aes(y = IRG/max(IRG), group = geeID), se = FALSE, col = 2)+
  geom_smooth(data = reg_colonies, se = FALSE, 
              aes(x = month(month), y = ratio, group = geeID), col = 1)+
  # coord_cartesian(xlim=c(0,12))+
  xlab("ratio")+ylab("month")+theme_classic()+
  facet_wrap(~round(Lat,2), ncol = 2)

```

## Plot colonies on map
```{r , echo=FALSE}
Africa <- ne_countries(continent = "Africa", scale = "medium", returnclass = "sf")
class(Africa)

reg_colonies$year <- year(reg_colonies$month)

batdf_max <- reg_colonies %>% group_by(Country, Location, year) %>% 
  summarise(size = max(ratio), 
            count = count[which.max(ratio)],
            Lat = Lat[which.max(ratio)],
            Long = Long[which.max(ratio)],
            date = month[which.max(ratio)])
batdf_max$yday <- yday(batdf_max$date)

batdf_max_mean <- batdf_max %>% group_by(Country, Location) %>% 
  summarise(size = mean(size),
            peak_size = mean(count),
            Lat = Lat[1],
            Long = Long[1],
            yday = round(circ.mean.yday(yday)))

batdf_max_mean

ggplot(data = Africa)+ geom_sf() +
  geom_point(data = batdf_max_mean, aes(x = Long, y = Lat, 
                               size = log10(peak_size), color = yday)) +
  coord_sf(xlim = c(-20, 45), ylim = c(-20, 20), expand = FALSE) + 
  theme_classic() +
  scale_color_gradient(low = "blue", high = "red", name = "Day of the Year")+
  xlab("Longitude")+ylab("Latitude") + guides(size = guide_legend(title = "Log(Peak Size)"))

```

# Find corresponding EVI and precipitation data for all colony data
```{r}
reg_colonies$evi <- NA
reg_colonies$irg <- NA
reg_colonies$precip <- NA

IDs <- 1:max(reg_colonies$geeID)
rs <- data.frame()
i = 1
for(i in 1:length(IDs)){
  ID <- i
  
  e <- subset(EVI, EVI$geeID == ID)
  p <- precip[,c(1,ID+1)]
  names(p) <- c("time", "precip")
  p$time <- ymd_hms(paste0(p$time, " 12:00:00"))
  
  e$time <- ymd_hms(e$startDate)
  c_idx <- which(reg_colonies$geeID == ID)
  colony <- reg_colonies[c_idx,]
  colony$time <- ymd(colony$month)
    
  par(mar = c(1,4,1,1), oma = c(1,1,1,1), xpd=FALSE)
  layout(rbind(1,2))
  
  plot(as.Date(ymd(ymd_hms(e$startDate))), e$mean, type = "l", lwd = 2,
       ylab = "EVI", xlab = "", ylim = c(0, 1), col = 3,
       xlim = c((min(colony$time)-years(1)), (max(colony$time)+years(1))),
       main = paste0(colonies$Location[colonies$geeID == i][1], ", ",
                     colonies$Country[colonies$geeID == i][1],
                     "; ID = ",ID))
  lines(x = p$time, y = p$precip/max(p$precip), col = 4)
  
  with(colony, points(time, ratio, type = "o"))
  mevi1 <- MEVI[MEVI$geeID == ID & MEVI$peak == 1,]
  mevi2 <- MEVI[MEVI$geeID == ID & MEVI$peak == 2,]
  # abline(v = ymd_hms(paste0(mevi1$date_EVI," 12:00:00")), col = "orange",
  #        lwd = (4*mevi1$amp)/max(c(mevi1$amp, mevi2$amp)))
  # abline(v = ymd_hms(paste0(mevi2$date_EVI," 12:00:00")), col = "brown",
  #        lwd = (4*mevi2$amp)/max(c(mevi1$amp, mevi2$amp)))
  # # abline(v = colonies$timestamp[colonies$geeID == ID], col = 2, lwd = 2)
  # legend("topright", legend = c("peak1", "peak2"), col = c("orange", "brown"), lty = 1)
  
  time <- as.Date(e$time)
  evi <- e$mean
  timep <- p$time
  # prp <- p$precip
  
  dl <- geosphere::daylength(colony$Lat[1], seq(1,331, by = 30))
  dayl <- data.frame(date = seq.Date(as.Date("2000-01-01"), 
                                     as.Date("2019-12-01"), 
                                     by = "month"), 
                     daylength = rep(dl, 20))
  dayl$geeID <- ID
  dayl$year <- year(dayl$date)
  lines(dayl$date, rescale(dayl$daylength), 
        col = "gold", lwd = 2)
  
  spl <- smooth.spline(x = time, y = evi)
  #spl_p <- smooth.spline(x = timep, y = prp)
  
  pred <- predict(spl)
  #predp <- predict(spl_p)
  e$pred <- pred$y
  #p$pred <- predp$y
  lines(pred, col=2)
  #lines(p$time, p$pred/max(p$pred), col = "darkblue")
  
  ## get derivative of EVI -> IRG
  # pred.prime <- predict(spl, deriv=1)
  # pred.prime$y_scale <- rescale(pred.prime$y, c(0,1))
  # e$pred.prime <- pred.prime$y_scale
  
  # # get derivative of precipitation
  # predp.prime <- predict(spl_p, deriv=1)
  # predp.prime$y_scale <- rescale(predp.prime$y, c(0,1))
  # p$pred.prime <- predp.prime$y_scale
  
  # plot first derivatives
  plot(as.Date(e$time), e$IRG/max(e$IRG), type = "l", ylab = "scaled IRG", col = 2,
       xlim = c((min(colony$time)-years(1)), (max(colony$time)+years(1))),
       ylim = c(-1, 1), xlab = "Date")
  # lines(p$time, p$pred.prime, col = 4)
  lines(dayl$date, rescale(dayl$daylength), 
        col = "gold", lwd = 2)

  with(colony, points(time, ratio, type = "o"))
  # abline(v = ymd_hms(paste0(mevi1$date_IRG," 12:00:00")), col = "orange",
  #        lwd = (4*mevi1$amp)/max(c(mevi1$amp, mevi2$amp)))
  # abline(v = ymd_hms(paste0(mevi2$date_IRG," 12:00:00")), col = "brown",
  #        lwd = (4*mevi2$amp)/max(c(mevi1$amp, mevi2$amp)))
  # 
  ## add EVI, IRG, and Precip to reg colonies
  for(j in 1:length(c_idx)){
    reg_colonies$evi[c_idx[j]] <- evi[which.min(abs(as.Date(colony$time[j]) - 
                                                      as.Date(time)))]
    reg_colonies$irg[c_idx[j]] <- e$IRG[which.min(abs(as.Date(colony$time[j]) -
                                                                     as.Date(time)))]
    reg_colonies$precip[c_idx[j]] <- p$precip[which.min(abs(as.Date(colony$time[j]) - 
                                                      as.Date(timep)))]
  }
  
  # ggplot() +
  #   geom_line(data = e, aes(x = ymd_hms(startDate), y = pred.prime), col = 2) +
  #   geom_point(data = colony, aes(x = time, y = ratio)) + ylab("IRG") + xlab("Date")+
  #   geom_segment(data = colony, aes(x = time, xend = time, y = 0, yend = ratio)) +
  #   xlim(c(min(colony$time)-years(1), max(colony$time)+years(1))) + 
  #   theme_bw()
  
  years <- unique(year(e$time))
  e$year <- year(e$time)
  # to account for double peaks in a season, we will  pull out half year estimates
  e$halfyear <- year(e$time)+round(month(e$time)/12, 0)/2
  e_sum <- e %>% group_by(halfyear, year, geeID) %>% 
    summarise(EVI_spline = time[which.max(pred)],
              IRG_spline = time[which.max(IRG)],
              EOS_spline = time[which.min(IRG)],
              max_IRG = IRG[which.max(IRG)],
              min_IRG = IRG[which.min(IRG)],
              max_EVI = pred[which.max(pred)],
              min_EVI = pred[which.min(pred)],
              area_EVI = trapz(as.numeric(time),pred))
  summary(p)
  p$year <- year(p$time)
  p$geeID <- ID
  p_sum <- p %>% group_by(year, geeID) %>% 
    summarise(precip_spline = time[which.max(precip)])

  MEVI$year <- year(MEVI$date_EVI)
  m_sum1 <- MEVI[MEVI$geeID == ID,] %>% group_by(geeID, year) %>% 
    summarise(EVI1_model = date_EVI[which(peak == 1)],
              EVI_model = date_EVI[which.max(amp)],
              IRG1_model = date_IRG[which(peak == 1)],
              IRG_model = date_IRG[which.max(amp)],
              amp = amp[which.max(amp)])
  
  m_sum2 <- MEVI[MEVI$geeID == ID,] %>% group_by(geeID, year) %>% 
    summarise(EVI2_model = date_EVI[which(peak == 2)],
              IRG2_model = date_IRG[which(peak == 2)])
  m_sum <- full_join(m_sum1, m_sum2)
  # dl_sum <- dayl %>% group_by(geeID, year) %>% 
  #   summarise(daylength_month = date[which.max(daylength)],
  #             daylength = daylength[which.max(daylength)])

  # plot(dayl$daylength)
  C <- full_join(e_sum, m_sum)
  # C <- full_join(C, dl_sum)
  C <- full_join(C, p_sum)
  rs <- rbind(rs, C)
}

save(reg_colonies, colonies, colony_sum, rs, file = "../../../../Dropbox/MPI/Eidolon/Greenwave/rdata/regular_colonies.Rdata")

# (rs$daylength) %>% plot
```  

# Check peak colony month
## find colony peaks
```{r}
Peaks <- data.frame()
IDs <- unique(reg_colonies$geeID)
i = 2
for(i in 1:length(IDs)){
  rc <- reg_colonies[reg_colonies$geeID == IDs[i],]
  
  # find peaks
  peak_time <- rc$month[findpeaks(rc$ratio)]
  
  # add any missed peaks at ratio of .6
  peak_time <- unique(c(peak_time, na.omit(rc$month[rc$ratio > 0.6])))
  
  peaks <- rc[which(rc$month %in% peak_time),]
  
  # plot peaks
  with(rc, plot(month, ratio, type = "o", pch = 16,
                col = as.numeric(is.na(Observer))+1,
                main = rc$Location[1]))
  abline(v = peaks$month, lty = 2) 
  
  # remove peaks with ratios below 0.4
  peaks <- peaks[which(peaks$ratio > 0.4),]
  
  # remove any interpolated peaks
  peaks <- peaks[!is.na(peaks$Observer),]
  
  # remove peaks that are within 6 months
  while(any(diff(peaks$month) < 180)){
    too_close <- which(diff(peaks$month) < 180)[1]
    # keep peak with higher ratio
    kick <- which.min(peaks$ratio[too_close:(too_close+1)])
    peaks <- peaks[-(too_close+kick-1),]
  }
  abline(v = peaks$month, lwd = 2, col = 4) 
  Peaks <- rbind(Peaks, peaks)
}

```

# plot colony and RS peaks 
```{r}
i = 11
rs_max <- rs %>% group_by(year, geeID) %>% 
  summarise(EVI_spline = EVI_spline[which.max(max_EVI)],
            IRG_spline = IRG_spline[which.max(max_IRG)],
            precip_spline = precip_spline[1])

for(i in 1:length(IDs)){
  p <- Peaks[which(Peaks$geeID == IDs[i]),]
  r <- rs_max[which(rs_max$geeID == IDs[i]),]
  # layout(c(1,2))
  
  plot(r$year, month(r$IRG_spline), type = "o", pch = 16,
       ylab = "month", xlab = "", col = 2,
       ylim = c(0,12), main = paste(p$Location[1], "spline"))
  # abline(v = 2000:2020, lty = 2)
  points(r$year, month(r$EVI_spline), type ="o", pch = 16, col = 3)
  points(r$year, month(r$precip_spline), type = "o", pch = 16, col = 4)
  # points(r$year, month(r$daylength_month), type = "o", pch = 16, col = "gold")
  points(x = p$year, y = month(p$month), col = 1, pch = 16, cex = 2)
  
  
  legend("bottomleft", legend = c("EVI", "IRG", "Precip", "Colony"), pch = 16, col = c(3,2,4,1))
  # plot(r$year, month(r$IRG_model), type = "o", pch = 16,
  #      ylab = "month", xlab = "", col = 3,
  #      ylim = c(0,12), main = paste(p$Location[1], "model"))
  # points(r$year, month(r$EVI_model), type ="o", pch = 16)
  # points(x = p$year, y = month(p$month), col = 2, pch = 16)
  # points(x = p$year, y = month(p$month), col = 2, pch = 16)
  
}

```

# Add start and end of season estimates to each peak
```{r}
# Peaks$sos <- NA
# Peaks$eos <- NA
# Peaks$months_to_SOS <- NA
# Peaks$months_to_EOS <- NA
# 
# years <- u
# nique(Peaks$year)
# i = 1
# for(i in 1:length(years)){
#   idx <- which(Peaks$year == years[i])
#   p <- Peaks[idx,]
# 
#   sos <- raster(paste0("C:/Users/Edward/MODIStsp/LandSurfacePhenology_Adole2019/SOS_YEARS/", years[i], "_SOS_DOY.tif"))
#   eos <- raster(paste0("C:/Users/Edward/MODIStsp/LandSurfacePhenology_Adole2019/EOS_YEARS/", years[i], "_EOS_DOY.tif"))
# 
#   # plot(sos)
#   # res(sos)
#   sos2 <- aggregate(sos, fact = 100)
#   eos2 <- aggregate(eos, fact = 100)
#   res(sos2)
#   plot(sos2)
#   plot(eos2)
# 
#   xy <- coordinates(cbind(p$Long, p$Lat))
#   Peaks$sos[idx] <- raster::extract(x = sos2, y = xy)
#   Peaks$eos[idx] <- raster::extract(eos2, xy)
# 
#   Peaks$months_to_SOS[idx] <- round(difftime(Peaks$month[idx],
#                                       as.Date(Peaks$sos[idx],
#                                               origin = paste0(year(Peaks$month),"-01-01")),
#                                       unit = "weeks")/4, 0) %>% as.numeric
#   Peaks$months_to_SOS[which(Peaks$months_to_SOS > 6)] <- round(yday(Peaks$month) - Peaks$sos)
# 
# 
#   sos <- {}
#   eos <- {}
# }
# 
# hist(Peaks$eos)
# hist(Peaks$sos)

```

# plot peaks on map by month
## one map
```{r}
avg_peaks <- Peaks %>% group_by(geeID, Location) %>% 
  summarise(count = mean(count), Lat = Lat[1], Long = Long[1], month = round(mean(month(month)),0))

ggplot(data = Africa)+ geom_sf() +
  geom_point(data = avg_peaks, aes(x = Long, y = Lat, col = month, 
                               size = log10(count))) +
  coord_sf(xlim = c(-20, 45), ylim = c(-20, 20), expand = FALSE) + 
  theme_classic() +
  scale_color_viridis_c(name = "Month")+
  xlab("Longitude")+ylab("Latitude") + guides(size = guide_legend(title = "Log(Peak Size)"))
```

## facet map
```{r}
ggplot(data = Africa)+ geom_sf() +
  geom_point(data = avg_peaks, aes(x = Long, y = Lat,
                               size = log10(count))) +
  coord_sf(xlim = c(-20, 45), ylim = c(-20, 20), expand = FALSE) + 
  theme_classic() +
  facet_wrap(~month)+
  xlab("Longitude")+ylab("Latitude") + guides(size = guide_legend(title = "Log(Peak Size)"))

save(avg_peaks, Peaks, reg_colonies, Africa, file = "../../../../Dropbox/MPI/Eidolon/Greenwave/rdata/avg_peaks.RData")
load("../../../../Dropbox/MPI/Eidolon/Greenwave/rdata/avg_peaks.RData")
```

# Time to peak
## months
```{r}
IDs <- unique(Peaks$geeID)
Peaks$EVI_spline <- ymd("1900-01-01")
Peaks$IRG_spline <- ymd("1900-01-01")
Peaks$EOS_spline <- ymd("1900-01-01")
Peaks$precip_spline <- ymd("1900-01-01")
Peaks$EVI1_model <- ymd("1900-01-01")
Peaks$IRG1_model <- ymd("1900-01-01")
Peaks$EVI2_model <- ymd("1900-01-01")
Peaks$IRG2_model <- ymd("1900-01-01")
Peaks$EVI_model <- ymd("1900-01-01")
Peaks$IRG_model <- ymd("1900-01-01")
Peaks$LOS_start <- ymd("1900-01-01")
Peaks$LOS_end <- ymd("1900-01-01")
Peaks$LOS <- NA
i = 1
for(i in 1:length(IDs)){
  pidx <- which(Peaks$geeID == IDs[i])
  p <- Peaks[pidx,]  
  r_half <- rs[rs$geeID == IDs[i],]
  r <- rs_max[rs_max$geeID == IDs[i],]
  j = 1
  for(j in 1:nrow(p)){
    # spline
    Peaks$EVI_spline[pidx[j]] <- round_date(
      ymd(r$EVI_spline[which.min(abs(p$month[j] - as.Date(r$EVI_spline)))]), 
      unit = "month")
    peak_EVI_diff <- abs(as.Date(Peaks$EVI_spline[pidx[j]]) - p$month[j])
    if(peak_EVI_diff > 182){
      Peaks$EVI_spline[pidx[j]] <- round_date(
        ymd(r_half$EVI_spline[which.min(abs(p$month[j] - as.Date(r_half$EVI_spline)))]), 
        unit = "month")
    }
    
    Peaks$IRG_spline[pidx[j]] <- round_date(
      ymd(r$IRG_spline[which.min(abs(p$month[j] - as.Date(r$IRG_spline)))]), 
      unit = "month")
    peak_IRG_diff <- abs(as.Date(Peaks$IRG_spline[pidx[j]]) - p$month[j])
    if(peak_IRG_diff > 182){
      Peaks$IRG_spline[pidx[j]] <- round_date(
        ymd(r_half$IRG_spline[which.min(abs(p$month[j] - as.Date(r_half$IRG_spline)))]), 
        unit = "month")
    }
    
    if(Peaks$IRG_spline[pidx[j]] == Peaks$EVI_spline[pidx[j]]){
       Peaks$EVI_spline[pidx[j]] <- round_date(
      ymd(r$EVI_spline[which.min(abs(p$month[j] - as.Date(r$EVI_spline)))]), 
      unit = "month")
    }    
    
    Peaks$LOS_start[pidx[j]] <- Peaks$IRG_spline[pidx[j]]
    # check if IRG occurs before peak EVI
    if(Peaks$IRG_spline[pidx[j]] > Peaks$EVI_spline[pidx[j]]){
      # if not, check for closer peaks with yearly data
      Peaks$LOS_start[pidx[j]] <- round_date(
      ymd(r$IRG_spline[which.min(abs(p$month[j] - as.Date(r$IRG_spline)))]), 
      unit = "month")
    }
    
    Peaks$EOS_spline[pidx[j]] <- round_date(
      ymd(r_half$EOS_spline[which.min(abs(p$month[j] - as.Date(r_half$EOS_spline)))]), 
      unit = "month")
    Peaks$LOS_end[pidx[j]] <- Peaks$EOS_spline[pidx[j]]
    # check if EOS occurs after peak EVI
    if(Peaks$EOS_spline[pidx[j]] < Peaks$EVI_spline[pidx[j]]){
      # if not, check for closer peaks with yearly data
      Peaks$LOS_end[pidx[j]] <- round_date(
      ymd(r$EOS_spline[which.min(abs(p$month[j] - as.Date(r$EOS_spline)))]), 
      unit = "month")
    }
    # calculate length of season
    Peaks$LOS[pidx[j]] <- Peaks$LOS_end[pidx[j]] - Peaks$LOS_start[pidx[j]]
    # check if length of season is over 365
    ii <- 0
    while(Peaks$LOS[pidx[j]] > 365){
      # if so, check for closer end of season in half year
      Peaks$LOS_end[pidx[j]] <- round_date(
      ymd(r_half$EOS_spline[which.min(abs(p$month[j] - as.Date(r_half$EOS_spline)))-ii]), 
      unit = "month")
      # recalculate end of season
      Peaks$LOS[pidx[j]] <- Peaks$LOS_end[pidx[j]] - Peaks$LOS_start[pidx[j]]
      ii <- ii + 1
    }
    # check if length of season is negative
    ii <- 0
    while(Peaks$LOS[pidx[j]] < 0){
      Peaks$LOS_end[pidx[j]] <- round_date(
      ymd(r_half$EOS_spline[which.min(abs(p$month[j] - 
                                            as.Date(r_half$EOS_spline)))+ii]), 
      unit = "month")
      Peaks$LOS[pidx[j]] <- Peaks$LOS_end[pidx[j]] - Peaks$LOS_start[pidx[j]]
      ii <- ii + 1
    }
    # precipitation
    Peaks$precip_spline[pidx[j]] <- round_date(
      r$precip_spline[which.min(abs(p$month[j] - as.Date(r$precip_spline)))], 
      unit = "month")
    
    # modis model
    Peaks$EVI_model[pidx[j]] <- round_date(
      ymd(r_half$EVI_model[which.min(abs(p$month[j] - as.Date(r_half$EVI_model)))]), 
      unit = "month")
    Peaks$IRG_model[pidx[j]] <- round_date(
      ymd(r_half$IRG_model[which.min(abs(p$month[j] - as.Date(r_half$IRG_model)))]), 
      unit = "month")
    Peaks$EVI1_model[pidx[j]] <- round_date(
      ymd(r_half$EVI1_model[which.min(abs(p$month[j] - as.Date(r_half$EVI1_model)))]), 
      unit = "month")
    Peaks$IRG1_model[pidx[j]] <- round_date(
      ymd(r_half$IRG1_model[which.min(abs(p$month[j] - as.Date(r_half$IRG1_model)))]), 
      unit = "month")
    Peaks$EVI2_model[pidx[j]] <- round_date(
      ymd(r_half$EVI2_model[which.min(abs(p$month[j] - as.Date(r_half$EVI2_model)))]), 
      unit = "month")
    Peaks$IRG2_model[pidx[j]] <- round_date(
      ymd(r_half$IRG2_model[which.min(abs(p$month[j] - as.Date(r_half$IRG2_model)))]), 
      unit = "month")
    # Peaks[pidx[j],10:19]
  }
}

Peaks$months_to_EVI_spline <- round(difftime(Peaks$month, 
                                             Peaks$EVI_spline, 
                                             unit = "weeks")/4,0) %>% as.numeric
Peaks$months_to_IRG_spline <- round(difftime(Peaks$month, 
                                             Peaks$IRG_spline, 
                                             unit = "weeks")/4,0) %>% as.numeric
Peaks$months_to_EOS_spline <- round(difftime(Peaks$month, 
                                             Peaks$LOS_end, 
                                             unit = "weeks")/4,0) %>% as.numeric
Peaks$months_to_precip_spline <- round(difftime(Peaks$month, 
                                                Peaks$precip_spline, 
                                                unit = "weeks")/4,0) %>% as.numeric
Peaks$months_to_EVI_model <- round(difftime(Peaks$month, 
                                            Peaks$EVI_model, 
                                            unit = "weeks")/4,0) %>% as.numeric
Peaks$months_to_IRG_model <- round(difftime(Peaks$month, 
                                            Peaks$IRG_model, 
                                            unit = "weeks")/4,0) %>% as.numeric
Peaks$months_to_EVI1_model <- round(difftime(Peaks$month, 
                                             Peaks$EVI1_model, 
                                             unit = "weeks")/4,0) %>% as.numeric
Peaks$months_to_IRG1_model <- round(difftime(Peaks$month, 
                                             Peaks$IRG1_model, 
                                             unit = "weeks")/4,0) %>% as.numeric
Peaks$months_to_EVI2_model <- round(difftime(Peaks$month, 
                                             Peaks$EVI2_model, 
                                             unit = "weeks")/4,0) %>% as.numeric
Peaks$months_to_IRG2_model <- round(difftime(Peaks$month, 
                                             Peaks$IRG2_model, 
                                             unit = "weeks")/4,0) %>% as.numeric

wilcox.test(Peaks$months_to_EVI_spline, Peaks$months_to_IRG_spline)
wilcox.test(Peaks$months_to_EOS_spline, Peaks$months_to_IRG_spline)
wilcox.test(Peaks$months_to_precip_spline, Peaks$months_to_IRG_spline)

```

# plot each peak and env data around it
```{r}
for(i in 1:nrow(Peaks)){
  p <- Peaks[i,]
  c <- colonies[colonies$geeID == p$geeID[1],]
  e <- EVI[EVI$geeID == p$geeID[1],]
  e$date <- as.Date(e$time)
  
  time <- as.Date(e$time)
  evi <- e$mean
  spl <- smooth.spline(x = time, y = evi)
  pred <- predict(spl)
  pred.prime <- predict(spl, deriv = 1)
  pred.prime$y01 <- rescale(pred.prime$y, new.min = -0.5, new.max = 0.5)
  plot(p$month, p$ratio, 
       xlim = c(min(p$month) - years(2), 
                max(p$month) + years(2)), 
       ylim = c(-0.5, 1), 
       xlab = "time",
       ylab = "EVI/ratio", 
       main = paste0(p$Location[1], " LOS: ", p$LOS))
  abline(v = seq.Date(as.Date("2000-01-01"), 
                      as.Date("2021-01-01"), by = "year"), 
         col = "gray", lty = 2)
  abline(h = 0)
  lines(c$date, c$ratio, lty = 3, col = "gray")
  lines(e$date, e$mean, col = 3)
  lines(pred, col = "darkgreen")
  lines(pred.prime$x, pred.prime$y01, col = "darkred")
  abline(v = p$LOS_start, col = 2, lty = 2, lwd = 2)
  abline(v = p$IRG_spline, col = 2)
  abline(v = p$EVI_spline, col = 3)
  abline(v = p$LOS_end, col = "purple", lty = 2, lwd = 2)
  abline(v = p$EOS_spline, col = "purple")
  
  # legend("topright", legend = c("Peak Colony Size", ))
}

```

```{r}
library(circular)

# cor.circular(deg2rad(Peaks$sos), deg2rad(yday(Peaks$IRG_spline)))
# plot(Peaks$sos, yday(Peaks$IRG_spline))
# 
# plot(deg2rad(Peaks$sos))
# points(x = 1:nrow(Peaks), y = deg2rad(yday(Peaks$IRG_spline)), col = 2)
```

## correlation
### circular correlation
```{r}
x <- rvonmises(n=50, mu=circular(0), kappa=3)
y <- x + rvonmises(n=50, mu=circular(pi), kappa=10)
cor.circular(x, y, test=TRUE)
```

```{r}
# https://jdblischak.github.io/fucci-seq/circ-simulation-correlation.html
# x <- circular(x = pi*month(Peaks$precip_spline)/12, template = "clock12", units = "radians")
# y <- circular(x = pi*month(Peaks$EVI_spline)/12, template = "clock12", units = "radians")
plot(month(Peaks$precip_spline), month(Peaks$EVI_spline))
# cor.circular(x,y)
cor(sin(pi*month(Peaks$precip_spline)/12), sin(pi*month(Peaks$EVI_spline)/12))

plot(month(Peaks$precip_spline), month(Peaks$IRG_spline))
cor(sin(pi*month(Peaks$precip_spline)/12), sin(pi*month(Peaks$IRG_spline)/12))
```

## distribution of peak EVI, IRG, and Precip ydays
```{r}
library(data.table)
p <- as.data.table(Peaks)
p_mlt <- melt(p, id.vars = c("Location", "Country", "geeID", 
                             "Long", "Lat", "month", "ratio", 
                             "count", "Observer", "year"), 
              measure.vars = c("months_to_EVI_spline", "months_to_EVI_model", 
                            "months_to_IRG_spline", "months_to_IRG_model",
                            "months_to_EOS_spline",
                            "months_to_precip_spline"))
ggplot(p_mlt, aes(x = variable, y = value, fill = variable))+
  geom_hline(yintercept = 0)+
  geom_violin() + geom_boxplot(width=.1)+
  theme(legend.position = "none",
  axis.text.x = element_text(angle = 30, vjust = 1, hjust=1))+
  ylim(c(-10,7))
```

# peak colony day vs peak evi day
## spline vs model
### color lat
```{r}
p1 <- ggplot(Peaks, aes(y = month(month), x = month(EVI_spline), col = Lat))+
  geom_point()+xlim(c(0,365))+ylim(c(0,365))+
  geom_smooth()+
  geom_abline(slope = 1, intercept = 0)+ylab("Peak Colony Day")+xlab("Peak EVI Day")+
  scale_color_viridis_c(name='Latitude', option='E', alpha=0.7)+
  theme_classic()+ggtitle("Spline")+
  coord_cartesian(xlim=c(0,12), ylim = c(0,12))

p2 <- ggplot(Peaks, aes(y = yday(month), x = yday(EVI_model), col = Lat))+
  geom_point()+xlim(c(0,365))+ylim(c(0,365))+
  geom_smooth(method = "lm")+
  geom_abline(slope = 1, intercept = 0)+ylab("Peak Colony Day")+xlab("Peak EVI Day")+
  scale_color_viridis_c(name='Latitude', option='E', alpha=0.7)+theme_classic()+ggtitle("MODIS Product")

ggarrange(p1,p2, ncol = 1)
```

# peak colony vs peak IRG day
## lat
```{r}
p1 <- ggplot(Peaks, aes(y = yday(month), x = yday(IRG_spline), col = (Lat)))+
  geom_point()+xlim(c(0,365))+ylim(c(0,365))+
  geom_smooth(method = "lm")+
  geom_abline(slope = 1, intercept = 0)+ylab("Peak Colony Day")+xlab("Peak IRG Day")+
  scale_color_viridis_c(name='Latitude', option='E', alpha=0.7)+theme_classic()+ggtitle("Spline")
p2 <- ggplot(Peaks, aes(y = yday(month), x = yday(IRG_model), col = (Lat)))+
  geom_point()+xlim(c(0,365))+ylim(c(0,365))+
  geom_smooth(method = "lm")+
  geom_abline(slope = 1, intercept = 0)+ylab("Peak Colony Day")+xlab("Peak IRG Day")+
  scale_color_viridis_c(name='Latitude', option='E', alpha=0.7)+theme_classic()+ggtitle("MODIS Product")

ggarrange(p1,p2, ncol = 1)
```
# peak colony vs peak IRG day
## abs lat
```{r}
hist(as.numeric(as.Date(Peaks$month) - Peaks$IRG_model))

p1 <- ggplot(Peaks, aes(y = yday(month), x = yday(IRG_spline), col = abs(Lat)))+
  geom_point()+xlim(c(0,365))+ylim(c(0,365))+
  geom_smooth(method = "lm")+
  geom_abline(slope = 1, intercept = 0)+ylab("Peak Colony Day")+xlab("Peak IRG Day")+
  scale_color_viridis_c(name='abs(Latitude)', option='E', alpha=0.7)+theme_classic()+ggtitle("Spline")

p2 <- ggplot(Peaks, aes(y = yday(month), x = yday(IRG_model), col = abs(Lat)))+
  geom_point()+xlim(c(0,365))+ylim(c(0,365))+
  geom_smooth(method = "lm")+
  geom_abline(slope = 1, intercept = 0)+ylab("Peak Colony Day")+xlab("Peak IRG Day")+
  scale_color_viridis_c(name='abs(Latitude)', option='E', alpha=0.7)+theme_classic()+ggtitle("MODIS Product")

ggarrange(p1,p2, ncol = 1)
```

# Plot EVI, IRG and Precip vs Peak Colony 
## linear correlation
```{r}
library(ggpmisc)
# https://stackoverflow.com/questions/7549694/add-regression-line-equation-and-r2-on-graph
my.formula <- y ~ x

p1 <- ggplot(Peaks, aes(y = yday(month), x = yday(EVI_spline), col = abs(Lat)))+
  geom_point()+xlim(c(0,365))+ylim(c(0,365))+
  geom_smooth(method = "lm")+
  geom_abline(slope = 1, intercept = 0)+ylab("Peak Colony Day")+xlab("Peak EVI Day")+
  scale_color_viridis_c(name='abs(Latitude)', option='E', alpha=0.7)+theme_classic() +
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label.., sep = "~~~")), 
                parse = TRUE)

p2 <- ggplot(Peaks, aes(y = yday(month), x = yday(IRG_spline), col = abs(Lat)))+
  geom_point()+xlim(c(0,365))+ylim(c(0,365))+
  geom_smooth(method = "lm")+
  geom_abline(slope = 1, intercept = 0)+ylab("Peak Colony Day")+xlab("Peak IRG Day")+
  scale_color_viridis_c(name='abs(Latitude)', option='E', alpha=0.7)+theme_classic()+
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label.., sep = "~~~")), 
                parse = TRUE)

p3 <- ggplot(Peaks, aes(y = yday(month), x = yday(precip_spline), col = abs(Lat)))+
  geom_point()+xlim(c(0,365))+ylim(c(0,365))+
  geom_smooth(method = "lm")+
  geom_abline(slope = 1, intercept = 0)+ylab("Peak Colony Day")+xlab("Peak Precipitation Day")+
  scale_color_viridis_c(name='abs(Latitude)', option='E', alpha=0.7)+theme_classic()+
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label.., sep = "~~~")), 
                parse = TRUE)


ggarrange(p1,p2,p3, ncol = 2, nrow = 2, common.legend = TRUE)

```

```{r}
library(ggpmisc)
# https://stackoverflow.com/questions/7549694/add-regression-line-equation-and-r2-on-graph
my.formula <- y ~ sin(pi*x/12)+cos(pi*x/12)

cbPalette <- c("#009E73", "#D55E00", "#56B4E9")

p1 <- 
  ggplot(Peaks, aes(y = month(month), 
                             x = month(EVI_spline)))+
                             #col = abs(Lat)))+
  geom_point(col = cbPalette[1])+xlim(c(0,12))+ylim(c(0,12))+
  # geom_smooth()+#, formula = my.formula)+
  geom_abline(slope = 1, intercept = 0)+
  ylab("Peak Colony Month")+xlab("Peak EVI Month")+
  # scale_color_viridis_c(name='abs(Latitude)', option='C', alpha=0.7)+
  theme_classic() +
  scale_y_continuous(breaks=c(3,6,9,12))+
  scale_x_continuous(breaks=c(3,6,9,12))+
  geom_text(y = 10, x = 2, 
            label = paste0("cor: ", 
                                round(cor.circular(
                                  y = pi*month(Peaks$month)/12, 
                                  x = pi*month(Peaks$EVI_spline)/12), 2)))
  # stat_poly_eq(formula = my.formula, 
  #               aes(label = paste(..rr.label.., sep = "~~~")), 
  #               parse = TRUE)

p2 <- ggplot(Peaks, aes(y = month(month), 
                                 x = month(IRG_spline)))+
                                 #col = abs(Lat)))+
  geom_point(col = cbPalette[2])+xlim(c(0,12))+ylim(c(0,12))+
  #geom_smooth(method = "lm", formula = my.formula)+
  geom_abline(slope = 1, intercept = 0)+
  ylab("Peak Colony Month")+xlab("Peak IRG Month")+
  # scale_color_viridis_c(name='abs(Latitude)', option='C', alpha=0.7)+
  theme_classic()+
  scale_y_continuous(breaks=c(3,6,9,12))+
  scale_x_continuous(breaks=c(3,6,9,12))+
  geom_text(y = 10, x = 4, 
            label = paste0("cor: ", 
                           round(cor.circular(
                             y = pi*month(Peaks$month)/12, 
                             x = pi*month(Peaks$IRG_spline)/12), 2)))
  # stat_poly_eq(formula = my.formula, 
  #               aes(label = paste(..rr.label.., sep = "~~~")), 
  #               parse = TRUE)

p3 <- 
  ggplot(Peaks, aes(y = month(month), 
                             x = month(precip_spline)))+
                             # col = abs(Lat)))+
  geom_point(col = cbPalette[3])+xlim(c(0,12))+ylim(c(0,12))+
  # geom_smooth(method = "lm", formula = my.formula)+
  geom_abline(slope = 1, intercept = 0)+
    ylab("Peak Colony Month")+xlab("Peak Precipitation Month")+
  # scale_color_viridis_c(name='abs(Latitude)', option='C', alpha=0.7)+
    theme_classic()+
    scale_y_continuous(breaks=c(3,6,9,12))+
    scale_x_continuous(breaks=c(3,6,9,12))+
  geom_text(y = 10, x = 2, 
            label = paste0("cor: ", 
                           round(cor.circular(
                             y = pi*month(Peaks$month)/12, 
                             x = pi*month(Peaks$precip_spline)/12), 2)))
  # stat_poly_eq(formula = my.formula, 
  #               aes(label = paste(..rr.label.., sep = "~~~")), 
  #               parse = TRUE)

ggarrange(p1,p2,p3, ncol = 2, nrow = 2, common.legend = TRUE)

```

# plot difference
```{r}
CC_mlt <- reshape2::melt(Peaks[,c("year", "Lat", "months_to_EVI_spline", "months_to_IRG_spline", "months_to_precip_spline")], id = c("year", "Lat"))

CC_mlt$variable <- plyr::revalue(CC_mlt$variable, c("months_to_EVI_spline"="Peak EVI", "months_to_IRG_spline"="Peak IRG", "months_to_precip_spline"="Peak Precip"))

# Compute the analysis of variance
res.aov <- aov(value ~ variable, data = CC_mlt)
# Summary of the analysis
summary(res.aov)

p4 <- ggplot(CC_mlt, aes(x = variable, 
                                    y = value, fill = variable)) + geom_hline(yintercept = 0) + 
  geom_violin(draw_quantiles = c(0.5)) + theme_classic() + 
  geom_jitter(width = 0.2, alpha = 0.2)+
  theme(legend.position = "none") + 
  scale_fill_manual(values=cbPalette)+
  # scale_fill_viridis_d() +
  ylab("Months to Peak Colony Size") + xlab("")+ylim(c(-10,7))


ggarrange(p1,p2,p3,p4, ncol = 2, nrow = 2, common.legend = FALSE)  

cols <- gg_color_hue(4)
ggplot(CC_mlt, aes(x = variable, 
                                    y = value, fill = variable)) + geom_hline(yintercept = 0) + 
  geom_violin(draw_quantiles = c(0.5)) + theme_classic() + 
  geom_jitter(width = 0.2, alpha = 0.2)+
  theme(legend.position = "none") + 
  scale_fill_manual(values=cols[c(1,3,2)])+
  # scale_fill_viridis_d() +
  ylab("Months to Peak Colony Size") + xlab("")+ylim(c(-10,7))
# add statistical tests
```

# model months to peak IRG

## prep data
```{r}
Peaks$abs_Lat <- abs(Peaks$Lat)
Peaks$log_colony_size <- log(Peaks$count)
Peaks$abs_months_to_IRG_spline <- abs(Peaks$months_to_IRG_spline)
hist(Peaks$months_to_IRG_spline)
```
## add lat long to rs
```{r}
rs$seasonality <- NA
for(i in 1:length(IDs)){
  rs$Lat[rs$geeID == IDs[i]] <- Peaks$Lat[Peaks$geeID == IDs[i]]
  rs$Long[rs$geeID == IDs[i]] <- Peaks$Long[Peaks$geeID == IDs[i]]
  rs$seasonality[rs$geeID == IDs[i]] <- Peaks$seasonality[Peaks$geeID == IDs[i]][1]
}

rs$abs_Lat <- abs(rs$Lat)
Peaks$abs_months_to_IRG_spline <- abs(Peaks$months_to_IRG_spline)
psych::pairs.panels(Peaks[,c("abs_months_to_IRG_spline", "evi", "irg")])
```
## plot seasonality
```{r}
ggplot(rs, aes(abs(Lat), seasonality))+
  geom_point(aes(col = factor(geeID)))+guides(col=guide_legend(ncol=2))+
  geom_smooth(method = "lm", col = 1)+theme_classic()
# ggplot(rs, aes(abs(Lat), Rmax, col = factor(geeID)))+
#   geom_point()+guides(col=guide_legend(ncol=2))
# ggplot(rs, aes(abs(Lat), Ra, col = factor(geeID)))+
#   geom_point()+guides(col=guide_legend(ncol=2))
# ggplot(rs, aes(abs(Lat), entropy, col = factor(geeID)))+
#   geom_point()+guides(col=guide_legend(ncol=2))

# ggplot(rs, aes(abs(Lat), pseasonality, col = factor(geeID)))+
#   geom_point()+guides(col=guide_legend(ncol=2))
# ggplot(rs, aes(abs(Lat), pRmax, col = factor(geeID)))+
#   geom_point()+guides(col=guide_legend(ncol=2))
# ggplot(rs, aes(abs(Lat), pRa, col = factor(geeID)))+
#   geom_point()+guides(col=guide_legend(ncol=2))
# ggplot(rs, aes(abs(Lat), pentropy, col = factor(geeID)))+
#   geom_point()+guides(col=guide_legend(ncol=2))

```

## join peaks and rs
```{r}
library(geosphere)
rs_max <- rs %>% group_by(year, geeID) %>% 
  summarise(
    
    
  )

rs$LOS <- rs$EOS_spline - rs$IRG_spline
idx <- which(rs$LOS < 0)

rs[idx,]
rs[(idx[1]-1):(idx[1]+1),]
for(i in 1:length(idx)){
  rs$LOS[idx[i]] <- rs$EOS_spline[idx[i]+1] - rs$IRG_spline[idx[i]]
}

rs$avg_LOS <- NA
IDs <- unique(rs$geeID)
i = 1
for(i in 1:length(IDs)){
  idx <- which(rs$geeID == IDs[i])
  SOS <- circ.mean.yday(yday(rs$IRG_spline[idx]))
  EOS <- circ.mean.yday(yday(rs$EOS_spline[idx]))
  if((EOS - SOS)>0) rs$avg_LOS[idx] <- EOS - SOS  
  if((EOS - SOS)<0) rs$avg_LOS[idx] <- SOS - EOS
}

for(i in 1:nrow(Peaks)){
  idx <- which(Peaks$geeID[i] == rs$geeID & Peaks$year[i] == rs$year)
  Peaks$amp[i] <-     max(rs$amp[idx], na.rm = TRUE)
  # Peaks$seasonality[i] <- rs$seasonality[idx]
  Peaks$max_EVI[i] <- max(rs$max_EVI[idx], na.rm = TRUE)
  Peaks$min_EVI[i] <- max(rs$min_EVI[idx], na.rm = TRUE)
  Peaks$LOS[i] <-     max(rs$LOS[idx], na.rm = TRUE)
  Peaks$avg_LOS[i] <- max(rs$avg_LOS[idx], na.rm = TRUE)
  Peaks$auc_EVI[i] <- max(rs$area_EVI[idx], na.rm = TRUE)
  Peaks$daylength[i]<-max(daylength(Peaks$Lat[i], 1:365))
}
Peaks$amp_EVI <- Peaks$max_EVI - Peaks$min_EVI

Peaks$log_colony_size <- log(Peaks$count)
Peaks$abs_Lat <- abs(Peaks$Lat)

summary(Peaks)
Peaks[which(is.na(Peaks$min_EVI)),]
rs
```


```{r}

log_min_bats
psych::pairs.panels(Peaks[,c("abs_months_to_IRG_spline", "log_colony_size", 
                             "ratio", "daylength", "max_EVI", "min_EVI",
                             "auc_EVI", "amp_EVI", "amp", "LOS", "avg_LOS")])
```

###### check for spatial autocorrelation
```{r}
# moran's I
library(tidyverse)
library(gridExtra)
library(NLMR)
library(DHARMa)

unique_peaks <- Peaks %>% group_by(Lat, Long) %>% 
  summarise(months_to_EVI = median(months_to_IRG_spline),
            season = median(seasonality))

m_non <- lm(months_to_EVI ~ season, unique_peaks)

sims <- simulateResiduals(m_non)
# sims_rc <- recalculateResiduals(m_non)
testSpatialAutocorrelation(sims, x = unique_peaks$Long, y = unique_peaks$Lat, plot = TRUE)
```

###### identify family for model
```{r}
library(fitdistrplus)
descdist(Peaks$months_to_IRG_spline %>% abs, boot = 1000)
```


#### dredge

##### abs
```{r}
library(lme4)
library(MuMIn)
summary(Peaks)

Peaks[which(is.na(Peaks$min_EVI)),]

no_kasanka <-  Peaks[which(Peaks$geeID != 14),]
no_accra <- Peaks[which(Peaks$geeID != 10),]

Peaks$months_to_IRG_spline %>% #abs %>% 
  hist(breaks = 6, main = "", xlab = "Months to Peak IRG")
table(Peaks$abs_months_to_IRG_spline)
m1 = glmer(abs(months_to_IRG_spline)~
             scale(LOS)+
             scale(avg_LOS)+
             scale(amp_EVI)+
             #scale(auc_EVI)+ # too correlated
             scale(max_EVI)+
             # scale(min_EVI)+  # correlated with amp
             # scale(daylength)+ #correlated with amp and min EVI
             # scale(log(count))+
             scale(log_colony_size)+
             scale(ratio)+
             (1|geeID),
          family = poisson(link = "log"),
           data = Peaks, #no_kasanka,#
          na.action=na.fail)
summary(m1)
r.squaredGLMM(m1)
sims <- simulateResiduals(m1)
plot(sims)
dd = dredge(m1)
dd[1]
```
### best
```{r}
m1_best = glmer(abs(months_to_IRG_spline)~
             #scale(avg_LOS)+
             scale(max_EVI)+
             scale(amp_EVI)+
             # scale(log_colony_size)+
             # scale(daylength)+
             # scale(min_EVI)+
               # scale(ratio)+
             (1|geeID),
          family = poisson(link = "log"),
           data = Peaks, #no_kasanka,#
          na.action=na.fail)
summary(m1_best)
r.squaredGLMM(m1_best)
sims <- simulateResiduals(m1_best)
plot(sims)
```
### interaction
```{r}
# m1i = glmer(abs(months_to_IRG_spline)~
#              (scale(avg_LOS)+
#              #scale(amp_EVI)+
#              #scale(auc_EVI)+
#              scale(max_EVI)+
#              scale(min_EVI)+
#              # scale(daylength)+
#              # scale(log(count))+
#              scale(log_colony_size)+
#              scale(ratio))^2+
#              (1|geeID),
#           family = poisson(link = "log"),
#            data = Peaks, #no_kasanka,#
#           na.action=na.fail)
#           #REML=FALSE)
# summary(m1i)
# r.squaredGLMM(m1i)
# sims <- simulateResiduals(m1i)
# plot(sims)
# ddi = dredge(m1i)
# ddi
# ddi[1]
```

### Leave one out cross validation
```{r}
IDs <- unique(reg_colonies$geeID)
fits <- list()
r.sq <- list()

Peaks$predictIRG <- NA
i = 1

for(i in 1:length(IDs)){
  df <- Peaks[Peaks$geeID != IDs[i],]
  
  fits[[i]] <- lmer((months_to_IRG_spline) ~ 
                     #scale(avg_LOS)+
                     scale(max_EVI)+
                     scale(amp_EVI)+
                     # scale(ratio)+
                   (1|geeID), 
             data = df)
  summary(fits[[i]])
  r.sq[[i]] <-  r.squaredGLMM(fits[[i]])
  
  df_out <- Peaks[Peaks$geeID == IDs[i],]
  Peaks$predictIRG[which(Peaks$geeID == IDs[i])] <- 
    predict(fits[[i]], df_out, allow.new.levels = TRUE)
}


library(ggpmisc)
# https://stackoverflow.com/questions/7549694/add-regression-line-equation-and-r2-on-graph
my.formula <- y ~ x

ggplot(Peaks, aes(abs(months_to_IRG_spline), predictIRG, col = Location))+
  geom_point()+
  geom_smooth(method = "lm", col = 1)+
  theme_classic()+
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label.., sep = "~~~")), 
                parse = TRUE)

r.sq_df <- sapply(r.sq, unlist)

plot(r.sq_df[2,], ylab = "R^2", xlab = "Dropped Colony",
     main = "Leave one Colony Out Model Performance")
abline(h = mean(r.sq_df[2,]))
```
## spatial glmm
```{r}
library(glmmfields)
library(ggplot2)
library(dplyr)
options(mc.cores = parallel::detectCores())

m_spatial <- glmmfields(as.numeric(months_to_IRG_spline) ~
                          log(count) + amp + ratio + seasonality + (1|geeID),
  data = Peaks, 
  #family = Gamma(link = "log"),
  lat = "Lat", lon = "Long", 
  nknots = 12, iter = 2000, chains = 4,
  prior_intercept = student_t(50, 200, 70), 
  prior_beta = student_t(50, -30, 3),
  prior_sigma = half_t(50, 0, 3),
  prior_gp_theta = half_t(50, 0, 10),
  prior_gp_sigma = half_t(50, 0, 3),
  seed = 123 # passed to rstan::sampling()
)
m_spatial
```

### plot spatial glmm
```{r}
plot(m_spatial, type = "spatial-residual", link = TRUE) +
  geom_jitter(size = 3, width = 1, height = 1)
```


```{r}
plot(m_spatial, type = "residual-vs-fitted")
```


## gam
```{r}
library(mgcv)
#Peaks$daylength <- geosphere::daylength(Peaks$Lat, yday(Peaks$month))
Peaks$Location <- as.factor(Peaks$Location)
```

### normal
```{r}
g <- gam(abs(months_to_IRG_spline)~
             # s(avg_LOS)+
             # s(LOS)+
             #s(amp_EVI, k = 5)+ # R2 = 0.32
             # s(auc_EVI, k = 5)+
             s(max_EVI, k = 10)+
             # s(min_EVI, k = 5)+
             s(daylength, k = 10)+ # r^2 = 0.37
             # s(log_colony_size, k = 10)+
             # s(ratio, k = 5)+
            # s(Long, Lat, k = 40, bs = "gp")+
            s(Location, bs = "re"),
            data = Peaks,
          method = "REML")
summary(g)
plot(g, scale = 0, shade = TRUE, scheme = 2)
gam.check(g, rep = 500)
```

#### spatial
```{r}
gs <- gam(abs(months_to_IRG_spline)~
            s(max_EVI)+
            s(daylength)+
            s(Long, Lat, k = 10, bs = "tp")+
            s(Location, bs = "re"),
            data = Peaks,
          method = "REML")
summary(gs)
plot(gs, scale = 0, shade = TRUE, scheme = 2)
gam.check(gs, rep = 500)
AIC(g, gs)
```


### nb
```{r}
g_nb <- gam(abs(months_to_IRG_spline)~
            s(max_EVI)+
            s(daylength)+
            #s(Long, Lat, k = 10, bs = "tp")+
            s(Location, bs = "re"),
            data = Peaks,
            family = nb,
          method = "REML")
summary(g_nb)
plot(g_nb, scale = 0, shade = TRUE, scheme = 2)
gam.check(g_nb, rep = 500)
```


#### spatial
```{r}
g_nbs <- gam(abs(months_to_IRG_spline)~
            s(max_EVI)+
            s(daylength)+
            s(Long, Lat, k = 10, bs = "tp")+
            s(Location, bs = "re"),
            data = Peaks,
            family = nb,
          method = "REML")
summary(g_nbs)
plot(g_nbs, scale = 0, shade = TRUE, scheme = 2)
gam.check(g_nbs, rep = 500)
```

### tw
```{r}
g_tw <- gam(abs(months_to_IRG_spline)~
            s(max_EVI)+
            s(daylength)+
            s(Location, bs = "re"),
            data = Peaks,
            family = tw,
          method = "REML")
summary(g_tw)
plot(g_tw, scale = 0, shade = TRUE, scheme = 2)
gam.check(g_tw, rep = 500)

AIC(g, g_nb, g_tw)
```
#### spatial
```{r}
g_tws <- gam(abs(months_to_IRG_spline)~
            s(max_EVI)+
            s(daylength)+
            
              s(Long, Lat, k = 10, bs = "tp")+
            s(Location, bs = "re"),
            data = Peaks,
            family = tw,
          method = "REML")
summary(g_tws)
plot(g_tws)
gam.check(g_tws, rep = 500)

aics <- AIC(g, gs, g_nb, g_nbs, g_tw, g_tws)
aics[order(aics$AIC),]
```

### ziP
```{r}
g_ziP <- gam(abs(months_to_IRG_spline)~
            s(max_EVI)+
            s(daylength)+
            s(Location, bs = "re"),
            data = Peaks,
            family = ziP,
          method = "REML")
summary(g_ziP)
plot(g_ziP, scale = 0, shade = TRUE, scheme = 2)
gam.check(g_ziP, rep = 5000)

AIC(g, g_nb, g_tw, g_ziP)
```
#### spatial
```{r}
g_ziPs <- gam(abs(months_to_IRG_spline)~
            s(evi, k = 5)+
            s(irg, k = 5)+
            # s(precip)+
            #s(daylength)+
            # s(month)+
            # s(year, k = 20)+
            s(Long, Lat, k = 10, bs = "tp"),
            #s(Location, bs = "re"),
            data = Peaks,
            family = ziP,
          method = "REML")
summary(g_ziPs)
plot(g_ziPs, scale = 0, shade = TRUE, scheme = 2)
gam.check(g_ziPs, rep = 500)

AIC(g, g_nb, g_tw, g_ziP, gs, g_nbs, g_tws, g_ziPs)
```


# model months to peak EVI
## dredge

### abs
```{r}
no_kasanka <-  Peaks[which(Peaks$geeID != 14),]

m1 = glmer(abs(months_to_EVI_spline)~scale(log(count))+
            scale(Long)+
            scale(amp)+
            scale(seasonality)+
            (1|geeID),
          family = poisson(link = "log"),
          data = Peaks, # no_kasanka,
          na.action=na.fail)
          #REML=FALSE)
summary(m1)
sims <- simulateResiduals(m1)
plot(sims)
dd = dredge(m1)
dd
```
### full
```{r}
m1 = glmer((months_to_EVI_spline)~scale(log(count))+
            scale(Long)+
            scale(amp)+
            scale(seasonality)+
            (1|geeID),
           # family = poisson(link = "log"),
          data = Peaks, # no_kasanka,
          na.action=na.fail)
          #REML=FALSE)
summary(m1)
sims <- simulateResiduals(m1)
plot(sims)
dd = dredge(m1)
dd
```
## Leave one out cross validation
```{r}
IDs <- unique(Colonies$geeID)
fits <- list()
r.sq <- list()
Peaks$predictEVI <- NA
i = 1

for(i in 1:length(IDs)){
  df <- Peaks[Peaks$geeID != IDs[i],]
  
  fits[[i]] <- lmer(abs(months_to_EVI_spline) ~ 
                     scale(Long)+
                      scale(log(count)) + 
                      scale(seasonality) + 
                   (1|geeID), 
             data = df)
  summary(fits[[i]])
  r.sq[[i]] <-  r.squaredGLMM(fits[[i]])
  
  df_out <- Peaks[Peaks$geeID == locations[i],]
  Peaks$predictEVI[which(Peaks$geeID == locations[i])] <- 
    predict(fits[[i]], df_out, allow.new.levels = TRUE)
}


library(ggpmisc)
# https://stackoverflow.com/questions/7549694/add-regression-line-equation-and-r2-on-graph
my.formula <- y ~ x

ggplot(Peaks, aes(abs(months_to_EVI_spline), predictEVI, col = Location))+
  geom_point()+
  geom_smooth(method = "lm", col = 1)+
  theme_classic()+
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label.., sep = "~~~")), 
                parse = TRUE)

r.sq_df <- sapply(r.sq, unlist)

plot(r.sq_df[2,], ylab = "R^2", xlab = "Dropped Colony",
     main = "Leave one Colony Out Model Performance")
abline(h = mean(r.sq_df[2,]))
```



# model months to peak Precip

```{r}
psych::pairs.panels(rs[,c("pR", "pRmax", "pseasonality", "pentropy", "Lat", "Long", "abs_Lat")])
```

## dredge

### abs
```{r}
no_kasanka <-  Peaks[which(Peaks$geeID != 14),]

m1 = lmer(abs(months_to_precip_spline)~
            scale(log(count))+
            scale(Long)+
            scale(amp)+
            scale(seasonality)+
            (1|geeID),
          data = Peaks, # no_kasanka,
          na.action=na.fail,
          REML=FALSE)
dd = dredge(m1)
dd
```
### full
```{r}
m1 = lmer((months_to_precip_spline)~scale(log(count))+
            scale(Long)+
            scale(amp)+
            scale(seasonality)+
            (1|geeID),
          data = Peaks, # no_kasanka,
          na.action=na.fail,
          REML=FALSE)
dd = dredge(m1)
dd
```
## Leave one out cross validation
```{r}
IDs <- unique(Colonies$geeID)
fits <- list()
r.sq <- list()
Peaks$predictPrecip <- NA
i = 1

for(i in 1:length(IDs)){
  df <- Peaks[Peaks$geeID != IDs[i],]
  
  fits[[i]] <- lmer(abs(months_to_precip_spline) ~ 
                     scale(Long)+
                      scale(log(count)) + 
                      scale(seasonality) + 
                   (1|geeID), 
             data = df)
  summary(fits[[i]])
  r.sq[[i]] <-  r.squaredGLMM(fits[[i]])
  
  df_out <- Peaks[Peaks$geeID == locations[i],]
  Peaks$predictPrecip[which(Peaks$geeID == locations[i])] <- 
    predict(fits[[i]], df_out, allow.new.levels = TRUE)
}


library(ggpmisc)
# https://stackoverflow.com/questions/7549694/add-regression-line-equation-and-r2-on-graph
my.formula <- y ~ x

ggplot(Peaks, aes(abs(months_to_precip_spline), predictPrecip, col = Location))+
  geom_point()+
  geom_smooth(method = "lm", col = 1)+
  theme_classic()+
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label.., sep = "~~~")), 
                parse = TRUE)

r.sq_df <- sapply(r.sq, unlist)

plot(r.sq_df[2,], ylab = "R^2", xlab = "Dropped Colony",
     main = "Leave one Colony Out Model Performance")
abline(h = mean(r.sq_df[2,]))
```





## plot time diff on map
```{r}
set.seed(42)
ggplot(Africa)+geom_sf()+
  geom_jitter(data = Peaks, width = 2, height = 2, 
              aes(Long, Lat, 
                  col = as.numeric(months_to_peakIRG),
                  size = log(peak_colony_size)))+
  scale_color_gradient2(low = "green", mid = "black", high = "red", 
                        name = "Months to peak IRG")+
  theme_classic()+ 
  labs(size = "ln(Peak Colony Size)")
```



















































## save peakIRG models
```{r}
save(fit, fits, fiti, fita, m_spatial, r.sq_df, Peaks, file = "../rdata/Eidolon_IRG_models.robj")
load("../rdata/Eidolon_IRG_models.robj")
```

# model abs months to peak IRG
```{r}
Colonies$abs_months_to_peakIRG <- abs(Colonies$months_to_peakIRG)
psych::pairs.panels(Colonies[Colonies$n > 6, c("months_to_peakIRG", "abs_Lat","Long","amp","log_colony_size", "seasonality", "entropy", "Ra")])

hist(na.omit(Colonies$months_to_peakIRG[Colonies$n > 6]) %>% abs %>%  as.numeric, 
     main = "", xlab = "Days to peak IRG", breaks = 11)
```
## glmm
```{r}

Peaks <- na.omit(Colonies[Colonies$n > 6,])

afit <- glmer(as.numeric(abs(months_to_peakIRG)) ~ (Lat) + Long + amp + 
              log(peak_colony_size) + seasonality + (1|geeID), 
             family = Gamma,
            data = Peaks)
summary(afit)

afiti <- lmer(as.numeric(abs(months_to_peakIRG)) ~ ((Lat) + Long)^2 + amp + 
               log(peak_colony_size) + seasonality + (1|geeID), 
           data = Peaks)
summary(afiti)
anova(afit, afiti)

afita <- lmer(as.numeric(abs(months_to_peakIRG)) ~ scale(abs(Lat)) + scale(Long) + 
               scale(amp) + 
               scale(log(peak_colony_size)) + 
               # scale(seasonality) + 
               (1|geeID),
             data = Peaks)
summary(afita)

afits <- lmer(as.numeric(abs(months_to_peakIRG)) ~ scale(Long) + 
               scale(log(peak_colony_size)) + scale(seasonality) + (1|geeID),
             data = Peaks)
summary(afits)

# anova(fita, fits)
AIC(afit, afiti, afita, afits)

```
## summary for best afit
```{r}
plot(afits)
summary(afits)
r.squaredGLMM(afits)
confint(afits)

# What is going on with residuals?
Peaks[which(abs(residuals(afits))>4),]

```

## calculate and plot residuals
```{r}
Peaks$mp_glm_residuals <- residuals(afits)
ggplot(Africa)+geom_sf()+
  geom_jitter(data = Peaks, 
              aes(Long, Lat, colour = abs(mp_glm_residuals)), 
              size = 3, width = 1, height = 1) +
  scale_color_gradient2(midpoint = 2, high = "darkred", low = "darkblue")+
  theme_classic()
```



## spatial glmm
```{r}
library(glmmfields)
library(ggplot2)
library(dplyr)
options(mc.cores = parallel::detectCores())

ma_spatial <- glmmfields(as.numeric(abs(months_to_peakPrecip)) ~
                          log(peak_colony_size) + amp + seasonality + (1|geeID),
  data = Peaks, 
  #family = Gamma(link = "log"),
  lat = "Lat", lon = "Long", 
  nknots = 12, iter = 2000, chains = 4,
  prior_intercept = student_t(50, 200, 70), 
  prior_beta = student_t(50, -30, 3),
  prior_sigma = half_t(50, 0, 3),
  prior_gp_theta = half_t(50, 0, 10),
  prior_gp_sigma = half_t(50, 0, 3),
  seed = 123 # passed to rstan::sampling()
)
mp_spatial
```

### plot spatial glmm
```{r}
plot(ma_spatial, type = "spatial-residual", link = TRUE) +
  geom_jitter(size = 3, width = 1, height = 1)
```


```{r}
plot(ma_spatial, type = "residual-vs-fitted")
```


## Leave one out cross validation
```{r}
locations <- unique(Colonies$geeID)
pfits <- list()
r.sq <- list()
Peaks$predictPrecip <- NA
i = 1

for(i in 1:length(locations)){
  df <- Peaks[Peaks$geeID != locations[i],]
  
  pfits[[i]] <- lmer(as.numeric(months_to_peakPrecip) ~ Long + 
                 log(peak_colony_size) + seasonality + 
                   (1|geeID), 
             data = df[df$peak_colony_ratio > 0.8,])
  summary(pfits[[i]])
  r.sq[[i]] <-  r.squaredGLMM(pfits[[i]])
  
  df_out <- Peaks[Peaks$geeID == locations[i],]
  Peaks$predictPrecip[which(Peaks$geeID == locations[i])] <- 
    predict(pfits[[i]], df_out, allow.new.levels = TRUE)
}


library(ggpmisc)
# https://stackoverflow.com/questions/7549694/add-regression-line-equation-and-r2-on-graph
my.formula <- y ~ x

ggplot(Peaks, aes(months_to_peakPrecip, predictPrecip))+
  geom_point()+
  geom_smooth(method = "lm", col = 1)+
  theme_classic()+
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label.., sep = "~~~")), 
                parse = TRUE)

r.sq_dfp <- sapply(r.sq, unlist)

plot(r.sq_dfp[2,])
abline(h = mean(r.sq_dfp[2,]))
```
## plot time diff on map
```{r}
set.seed(42)
ggplot(Africa)+geom_sf()+
  geom_jitter(data = Peaks, width = 2, height = 2, 
              aes(Long, Lat, 
                  col = as.numeric(months_to_peakPrecip),
                  size = log(peak_colony_size)))+
  scale_color_gradient2(low = "green", mid = "black", high = "red", 
                        name = "Months to peak Precip")+
  theme_classic()+ 
  labs(size = "ln(Peak Colony Size)")
```
## save peakPrecip models
```{r}
save(pfit, pfits, pfiti, pfita, mp_spatial, r.sq_dfp, Peaks, file = "../rdata/Eidolon_Precip_models.robj")
```




# model days to peak Precip
## days

## months
```{r}
Colonies$months_to_peakPrecip 

psych::pairs.panels(Colonies[Colonies$n > 6, c("months_to_peakPrecip", "abs_Lat","Long","amp","log_colony_size", "seasonality", "entropy", "Ra")])

hist(na.omit(Colonies$months_to_peakPrecip[Colonies$n > 6]) %>% as.numeric, 
     main = "", xlab = "Months to peak Precip", breaks = 11)
```

## glmm
```{r}
Peaks <- na.omit(Colonies[Colonies$n > 6,])

pfit <- lmer(as.numeric(months_to_peakPrecip) ~ (Lat) + Long + amp + 
              log(peak_colony_size) + seasonality + (1|geeID), 
            data = Peaks)
summary(pfit)

pfiti <- lmer(as.numeric(months_to_peakPrecip) ~ ((Lat) + Long)^2 + amp + 
               log(peak_colony_size) + seasonality + (1|geeID), 
           data = Peaks)
summary(pfiti)
anova(pfit, pfiti)

pfita <- lmer(as.numeric(months_to_peakPrecip) ~ scale(abs(Lat)) + scale(Long) + 
               scale(amp) + 
               scale(log(peak_colony_size)) + 
               # scale(seasonality) + 
               (1|geeID),
             data = Peaks)
summary(pfita)

pfits <- lmer(as.numeric(months_to_peakPrecip) ~ scale(Long) + 
               scale(log(peak_colony_size)) + scale(seasonality) + (1|geeID),
             data = Peaks)
summary(pfits)

# anova(pfita, pfits)
AIC(pfit, pfiti, pfita, pfits)

```

## summary for best pfit
```{r}
plot(pfits)
summary(pfits)
r.squaredGLMM(pfits)
confint(pfits)

# What is going on with residuals?
Peaks[which(abs(residuals(pfits))>4),]

```

## calculate and plot residuals
```{r}
Peaks$mp_glm_residuals <- residuals(pfits)
ggplot(Africa)+geom_sf()+
  geom_jitter(data = Peaks, 
              aes(Long, Lat, colour = abs(mp_glm_residuals)), 
              size = 3, width = 1, height = 1) +
  scale_color_gradient2(midpoint = 2, high = "darkred", low = "darkblue")+
  theme_classic()
```


## spatial glmm
```{r}
library(glmmfields)
library(ggplot2)
library(dplyr)
options(mc.cores = parallel::detectCores())

mp_spatial <- glmmfields(as.numeric(months_to_peakPrecip) ~
                          log(peak_colony_size) + amp + seasonality + (1|geeID),
  data = Peaks, 
  #family = Gamma(link = "log"),
  lat = "Lat", lon = "Long", 
  nknots = 12, iter = 2000, chains = 4,
  prior_intercept = student_t(50, 200, 70), 
  prior_beta = student_t(50, -30, 3),
  prior_sigma = half_t(50, 0, 3),
  prior_gp_theta = half_t(50, 0, 10),
  prior_gp_sigma = half_t(50, 0, 3),
  seed = 123 # passed to rstan::sampling()
)
mp_spatial
```

### plot spatial glmm
```{r}
plot(mp_spatial, type = "spatial-residual", link = TRUE) +
  geom_jitter(size = 3, width = 1, height = 1)
```


```{r}
plot(mp_spatial, type = "residual-vs-fitted")
```


## Leave one out cross validation
```{r}
locations <- unique(Colonies$geeID)
pfits <- list()
r.sq <- list()
Peaks$predictPrecip <- NA
i = 1

for(i in 1:length(locations)){
  df <- Peaks[Peaks$geeID != locations[i],]
  
  pfits[[i]] <- lmer(as.numeric(months_to_peakPrecip) ~ Long + 
                 log(peak_colony_size) + seasonality + 
                   (1|geeID), 
             data = df[df$peak_colony_ratio > 0.8,])
  summary(pfits[[i]])
  r.sq[[i]] <-  r.squaredGLMM(pfits[[i]])
  
  df_out <- Peaks[Peaks$geeID == locations[i],]
  Peaks$predictPrecip[which(Peaks$geeID == locations[i])] <- 
    predict(pfits[[i]], df_out, allow.new.levels = TRUE)
}


library(ggpmisc)
# https://stackoverflow.com/questions/7549694/add-regression-line-equation-and-r2-on-graph
my.formula <- y ~ x

ggplot(Peaks, aes(months_to_peakPrecip, predictPrecip))+
  geom_point()+
  geom_smooth(method = "lm", col = 1)+
  theme_classic()+
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label.., sep = "~~~")), 
                parse = TRUE)

r.sq_dfp <- sapply(r.sq, unlist)

plot(r.sq_dfp[2,])
abline(h = mean(r.sq_dfp[2,]))
```
## plot time diff on map
```{r}
set.seed(42)
ggplot(Africa)+geom_sf()+
  geom_jitter(data = Peaks, width = 2, height = 2, 
              aes(Long, Lat, 
                  col = as.numeric(months_to_peakPrecip),
                  size = log(peak_colony_size)))+
  scale_color_gradient2(low = "green", mid = "black", high = "red", 
                        name = "Months to peak Precip")+
  theme_classic()+ 
  labs(size = "ln(Peak Colony Size)")
```
## save peakPrecip models
```{r}
save(pfit, pfits, pfiti, pfita, mp_spatial, r.sq_dfp, Peaks, file = "../rdata/Eidolon_Precip_models.robj")
```




# GAM
```{r}
library(mgcv)
colonies

pfitgam <- gam(as.numeric(months_to_peakIRG) ~ s(seasonality) + s(Long) + s(amp) + s(log(peak_colony_size)), 
              data = Peaks, 
              method = "REML")
plot(pfitgam)
```



```{r}
# as.Date(Colonies$month) - Colonies$peak1_EVI_day
# as.Date(Colonies$month) - Colonies$peak2_EVI_day
layout(cbind(c(1:2)))

with(Peaks, plot(yday(month), 
                    yday(peak_EVI_day), col = geeID, pch = 16,
                    ylab = "Predicted Peak EVI day",
                    xlab = "Peak Colony Day",
                    ylim = c(0,365), xlim = c(0,365)))
abline(1,1)

with(Peaks, plot(yday(month), 
                    yday(max_peak_EVI_day), col = geeID, pch = 16,
                    ylab = "Peak EVI day",
                    xlab = "Peak Colony Day",
                    ylim = c(0,365), xlim = c(0,365)))
abline(1,1)

```


```{r}
with(Peaks, plot(yday(month), 
                    yday(IRG_spline), col = geeID, pch = 16,
                    ylab = "Predicted Peak IRG Day",
                    ylim = c(0,365), xlim = c(0,365)))
abline(1,1)

with(Peaks, plot(yday(month), 
                    yday(peak1_IRG_day), col = geeID, pch = 16,
                    ylab = "Peak1 IRG Day",
                    ylim = c(0,365), xlim = c(0,365)))
abline(1,1)

with(Peaks, plot(yday(month), 
                    yday(peak2_IRG_day), col = geeID, pch = 16,
                    ylab = "Peak2 IRG Day",
                    ylim = c(0,365), xlim = c(0,365)))
abline(1,1)
```
```{r}
ggplot(Colonies, aes(x = abs(Lat), y = days_to_peak_IRG, col = factor(geeID)))+geom_point()+geom_hline(yintercept = 0)
```


```{r}
ggplot(Colonies, aes(x = yday(month), 
                     y = yday(pred_peak_irg_day), col = Lat))+geom_point()+
  geom_abline(slope = 1, intercept = 0)


ggplot(Colonies, aes(y = (as.Date(month) - as.Date(pred_peak_irg_day)), x = Lat))+geom_point()


```




```{r}
with(Colonies[abs(Colonies$Lat) > 10,], plot(yday(month), 
                    yday(pred_peak_irg_day), col = geeID, pch = 16,
                    ylab = "Predicted Peak IRG Day",
                    ylim = c(0,365), xlim = c(0,365)))
abline(1,1)

with(Colonies[abs(Colonies$Lat) > 10,], plot(yday(month), 
                    yday(peak1_IRG_day), col = geeID, pch = 16,
                    ylab = "Peak1 IRG Day",
                    ylim = c(0,365), xlim = c(0,365)))
abline(1,1)

with(Colonies[abs(Colonies$Lat) > 10,], plot(yday(month), 
                    yday(peak2_IRG_day), col = geeID, pch = 16,
                    ylab = "Peak2 IRG Day",
                    ylim = c(0,365), xlim = c(0,365)))
abline(1,1)
```


# for longterm data, how do changes in weather lead to changes in bats?
## Kasanka
```{r}
k <- Colonies[Colonies$geeID == 14,]

ggplot(k, aes(x = year(month), y = yday(month)))+
  geom_point()+
  geom_line()+
  geom_point(aes(y = yday(IRG_spline)), col = 3)+
  geom_line(aes(y = yday(IRG_spline)), col = 3) +
  # geom_point(aes(y = yday(peak_EVI_day)), col = 6)+
  # geom_line(aes(y = yday(peak_EVI_day)), col = 6)
  ylab("Day of the Year")+ 
  xlab("Year")+
  theme_bw()
  
# how correlated are they?
with(k[k$peak_colony_ratio > 0.8,], cor(yday(month), yday(IRG_spline)))

```
## Accra
```{r}
a <- Colonies[Colonies$geeID == 10,]
a$year <- year(a$month)

# remove duplicate year
## choose event with larger size



ggplot(a[a$peak_colony_ratio > .8,], aes(x = year(month), y = yday(month)))+
  geom_point()+
  geom_line()+
  geom_point(aes(y = yday(IRG_spline)), col = 3)+
  geom_line(aes(y = yday(IRG_spline)), col = 3) +
  # geom_point(aes(y = yday(peak_EVI_day)), col = 6)+
  # geom_line(aes(y = yday(peak_EVI_day)), col = 6)
  ylab("Day of the Year")+ 
  xlab("Year")+
  theme_bw()
  
# how correlated are they?
with(a[a$peak_colony_ratio > 0.8,], cor(yday(month), yday(IRG_spline)))

```



### Arrival and departure of bats in Kasanka
```{r}
kad <- read.csv("../../../../Dropbox/MPI/Eidolon/Data/Monitoring/Kasanka_Eidolon_Arrival_Departure.csv")


```



```{r}
IDs <- 1:max(colonies$geeID)
# Colonies <- data.frame()
i = 14
  ID <- i
  
  e <- subset(EVI, EVI$geeID == ID)
  
  
  
  e$time <- ymd_hms(e$startDate)
  colony <- colonies[colonies$geeID == ID,]
  colony$time <- ymd_hms(paste0(colony$timestamp, " 12:00:00"))
  
  ggplot(colony, aes(x = time, y = Count/1000000))+geom_path()+
    ylab("Count (in millions)")+
    ggtitle("Kasanka National Park")+
    theme_classic()
  
  
  ggplot(colony, aes(x = yday(time), y = ratio))+ # , col = factor(year(time))))+
    geom_smooth(method = "gam")+
    geom_point(aes(col = factor(year(time))))+
    xlab("Day of the Year")+ylab("Ratio of Peak Colony Size")+
    xlim(c(yday("2003-09-07"),yday("2003-12-28")))+
    theme_classic()+guides(col=guide_legend(title="Year"))
  
    
  par(mar = c(1,4,1,1), oma = c(1,1,1,1), xpd=FALSE)
  layout(rbind(1,2))
  
  plot(ymd_hms(e$startDate), e$mean, type = "l", lwd = 2,
       ylab = "EVI", xlab = "", ylim = c(0, 1), col = 3,
       xlim = c((min(colony$time)-years(1)), (max(colony$time)+years(1))),
       main = paste0(colonies$Location[colonies$geeID == i][1], ", ",
                     colonies$Country[colonies$geeID == i][1],
                     "; ID = ",ID))
  with(colony, points(time, ratio, type = "o"))
  mevi1 <- MEVI[MEVI$geeID == ID & MEVI$peak == 1,]
  mevi2 <- MEVI[MEVI$geeID == ID & MEVI$peak == 2,]
  # abline(v = ymd_hms(paste0(mevi1$date_EVI," 12:00:00")), col = "orange",
  #        lwd = (4*mevi1$amp)/max(c(mevi1$amp, mevi2$amp)))
  # abline(v = ymd_hms(paste0(mevi2$date_EVI," 12:00:00")), col = "brown",
  #        lwd = (4*mevi2$amp)/max(c(mevi1$amp, mevi2$amp)))
  # abline(v = colonies$timestamp[colonies$geeID == ID], col = 2, lwd = 2)
  # legend("topright", legend = c("peak1", "peak2"), col = c("orange", "brown"), lty = 1)
  
  time <- e$time
  evi <- e$mean
  
  spl <- smooth.spline(x = time, y = evi)
  pred <- predict(spl, spar = 0.6)
  e$pred <- pred$y
  lines(pred, col=2)
  
  pred.prime <- predict(spl, deriv=1)
  pred.prime$y_scale <- rescale(pred.prime$y, c(0,1))
  e$pred.prime <- pred.prime$y_scale
  
  plot(e$time, pred.prime$y_scale, type = "l", ylab = "scaled IRG", col = 2,
       xlim = c((min(colony$time)-years(1)), (max(colony$time)+years(1))),
       ylim = c(0, 1), xlab = "Date")

  with(colony, points(time, ratio, type = "o"))
  abline(v = ymd_hms(paste0(mevi1$date_IRG," 12:00:00")), col = "orange",
         lwd = (4*mevi1$amp)/max(c(mevi1$amp, mevi2$amp)))
  abline(v = ymd_hms(paste0(mevi2$date_IRG," 12:00:00")), col = "brown",
         lwd = (4*mevi2$amp)/max(c(mevi1$amp, mevi2$amp)))

  # ggplot() +
  #   geom_line(data = e, aes(x = ymd_hms(startDate), y = pred.prime), col = 2) +
  #   geom_point(data = colony, aes(x = time, y = ratio)) + ylab("IRG") + xlab("Date")+
  #   geom_segment(data = colony, aes(x = time, xend = time, y = 0, yend = ratio)) +
  #   xlim(c(min(colony$time)-years(1), max(colony$time)+years(1))) + 
  #   theme_bw()
  
  C <- data.frame()
  years <- unique(year(colony$time))
  
  for(j in 1:length(years)){
    d <- colony[year(colony$time) == years[j],]
    didx <- which(d$ratio == 1)
    if(length(didx) == 0){
      didx <- which.max(d$ratio)  
    }
    if(length(didx) > 1){
      if(mean(diff(didx)) == 1) didx <- round(median(didx))
    }
    
    for(k in 1:length(didx)){
      t1 <- d$time[didx[k]]
      idx <- which.min(abs(e$time - t1))
      
      # Peak EVI
      evi <- pred$y[idx]
      idxx <- (idx-10):(idx+10)
      peak_EVI_day <- e$time[idxx[which.max(pred$y[idxx])]]
      
      midx1 <- which.min(abs(ymd_hms(paste0(mevi1$date_EVI, " 12:00:00")) - t1))
      peak1_EVI_day <- mevi1$date_EVI[midx1]
      
      midx2 <- which.min(abs(ymd_hms(paste0(mevi2$date_EVI, " 12:00:00")) - t1))
      peak2_EVI_day <- mevi2$date_EVI[midx2]
      
      # Peak IRG
      
      irg <- pred.prime$y[which.min(abs(e$time - t1))]
      irg_scale <- pred.prime$y_scale[which.min(abs(e$time - t1))]
      peak_irg_day <- e$time[idxx[which.max(pred.prime$y[idxx])]]
      
      midx1 <- which.min(abs(ymd_hms(paste0(mevi1$date_IRG, " 12:00:00")) - t1))
      peak1_IRG_day <- mevi1$date_IRG[midx1]
      
      midx2 <- which.min(abs(ymd_hms(paste0(mevi2$date_IRG, " 12:00:00")) - t1))
      peak2_IRG_day <- mevi2$date_IRG[midx2]
      
      amp1 <- mevi1$amp[midx1]
      amp2 <- mevi2$amp[midx2]
        
      area1 <- mevi1$area[midx1]
      area2 <- mevi2$area[midx2]
      
      qa1 <- mevi1$QA[midx1]
      qa2 <- mevi2$QA[midx2]
      
      c <- data.frame(geeID = d$geeID[didx[k]], Lat = d$Lat[didx[k]], Long = d$Long[didx[k]], 
                      month = t1, 
                      peak_colony_size = d$Count[didx[k]],
                      peak_colony_ratio = d$ratio[didx[k]],
                      pred_peak_evi_day = peak_EVI_day, 
                      evi_pred_peak = evi,
                      peak1_EVI_day,
                      peak2_EVI_day,
                      
                      pred_peak_irg_day = peak_irg_day,
                      irg_pred_peak = irg, 
                      irg_pred_scale = irg_scale, 
                      peak1_IRG_day,
                      peak2_IRG_day,
                      amp1,
                      amp2,
                      area1,
                      area2,
                      qa1,
                      qa2)
      C <- rbind(C, c)  
    }  
  }
    
  # Colonies <- rbind(Colonies, C)

i = 17
Colonies
```



# get gbif 
```{r occurrence data}

splist <- c('Eidolon helvum')
keys <- vapply(splist, function(x) name_backbone(name = x)$speciesKey, integer(1))
eidolon <- occ_search(taxonKey = keys, hasCoordinate = TRUE)

plot(yday(ymd_hms(eidolon$data$eventDate)), eidolon$data$decimalLatitude, 
     col = year(ymd_hms(eidolon$data$eventDate)))
year(ymd_hms(eidolon$data$eventDate)) %>% unique

gbif_map <- ggplot(data = Africa)+ geom_sf() +
  geom_point(data = eidolon$data, aes(x = decimalLongitude, y = decimalLatitude, 
                                      col = yday(ymd_hms(eidolon$data$eventDate))))+
  # facet_wrap(~year(ymd_hms(eidolon$data$eventDate)))+
  theme_classic() +
  scale_color_gradient2(low = "blue", mid = "yellow", midpoint = 182, high = "red")+
  xlab("Longitude")+ylab("Latitude")+labs(col = "DoY")

ggplot(data = eidolon$data, aes(x = yday(ymd_hms(eidolon$data$eventDate)), 
                                      y = decimalLatitude, 
                                      col = factor(year(ymd_hms(eidolon$data$eventDate)))))+
  geom_point(alpha = 0.3)+
  geom_smooth(se = FALSE)+
  geom_abline(slope = 0, intercept = 0)+
  labs(col = "Year")+xlab("DoY")+
  facet_wrap(~factor(year(ymd_hms(eidolon$data$eventDate))))+
  theme(legend.position = "none")

```
### split by longitude ----
```{r}

eidolon$data$decimalLongitude %>% hist

east_africa <- eidolon$data[eidolon$data$decimalLongitude > 20,]

p2 <- ggplot(data = east_africa, 
       aes(x = yday(ymd_hms(eventDate)),
           y = decimalLatitude))+
  geom_smooth(se = FALSE)+
  geom_point(aes(col = factor(year(ymd_hms(eventDate)))), alpha = 0.3)+
  geom_abline(slope = 0, intercept = 0)+
  labs(col = "Year")+xlab("DoY")+ylab("Latitude")+ggtitle("East Africa")+
  # facet_wrap(~factor(year(ymd_hms(eventDate))))+
  theme(legend.position = "none")

west_africa <- eidolon$data[eidolon$data$decimalLongitude < 20,]

p1 <- ggplot(data = west_africa, 
       aes(x = yday(ymd_hms(eventDate)),
           y = decimalLatitude))+
  geom_smooth(se = FALSE)+
  geom_point(aes(col = factor(year(ymd_hms(eventDate)))), alpha = 0.3)+
  geom_abline(slope = 0, intercept = 0)+
  labs(col = "Year")+xlab("DoY")+ylab("Latitude")+ggtitle("West Africa")+
  # facet_wrap(~factor(year(ymd_hms(eventDate))))+
  theme(legend.position = "none")

ggarrange(p1,p2)
```


## iNaturalist data
```{r}

library(rinat)
ed <- get_inat_obs(query = "Eidolon helvum")
ed <- ed[ed$latitude < 25,]

my_title <- expression(paste("GBIF & iNaturalist ", italic("Eidolon helvum")))

gbif_map +
  geom_point(data = ed, aes(longitude, latitude, col = yday(ymd(observed_on))))+
  scale_color_gradient2(low = "blue", mid = "yellow", midpoint = 182, high = "red")+
  xlab("Longitude")+ylab("Latitude")+labs(col = "DoY")+theme_classic()+
  ggtitle(my_title)

ggplot(data = ed, aes(x = yday(ymd(observed_on)), 
                      y = latitude, col = factor(year(ymd(observed_on)))))+
  geom_point(alpha = 0.3)+
  geom_smooth(se = FALSE)+
  geom_abline(slope = 0, intercept = 0)+
  labs(col = "Year")+xlab("DoY")+
  facet_wrap(~factor(year(ymd(observed_on))))
```



## model inat data
```{r}
library(mgcv)

ed <- ed[ed$quality_grade == "research",]

recs <- data.frame(time = c(ymd_hms(ed$time_observed_at), ymd_hms(eidolon$data$eventDate)), 
                   lat = c(ed$latitude, eidolon$data$decimalLatitude), 
                   lon = c(ed$longitude, eidolon$data$decimalLongitude), 
                   source = c(rep("iNat", nrow(ed)), rep("GBIF", nrow(eidolon$data))))

recs$yday <- yday(recs$time)
recs$month <- month(recs$time)


ggplot(Africa)+geom_sf()+
  geom_point(data = na.omit(recs), aes(lon, lat, col = factor(month)))+
  facet_wrap(~month)+xlab("Longitude")+ylab("Latitude")+
  theme(legend.position = "none", axis.text.x = element_text(angle=30, hjust = 1))
# model species distribution
# incorporate day of year or week as a covariate
```

# animate citizen data
```{r}
library(gganimate)
# setwd("../../../../Dropbox/MPI/Eidolon/Plots/SpeciesDistribution/")

p <- ggplot(Africa)+geom_sf()+
  geom_point(data = na.omit(recs), aes(lon, lat, col = factor(month), 
                                       group = seq_along(month)), size = 3)+
  labs(title = 'Eidolon helvum yearly occurrence; month: {round(frame_time)}', 
       col = "Month", x = 'Longitude', y = 'Latitude') +
  transition_time(month)+
  theme_classic()+
  theme(legend.position = "none")+
  enter_fade() +
  exit_shrink()

animate(p, renderer = gifski_renderer())

# p1 <- ggplot(Africa)+geom_sf()+
#   geom_point(data = na.omit(recs), aes(lon, lat, col = factor(month)))+
#   geom_density_2d_filled(data = na.omit(recs), aes(lon, lat), alpha = 0.5)+
#   xlab("Longitude")+ylab("Latitude")+
#   # facet_wrap(~month)
#   transition_states(month)
# 
# animate(p1, renderer = gifski_renderer())
```

## model citizen science presence
```{r}
# pseudo locations?

# timing?

```

# save
```{r}
save(Colonies, m_spatial, file = "../data/Colony_IRG_fit.robj")
```

